{"version":3,"sources":["04_particles_animation/index.js"],"names":["canvas","document","querySelector","gl","getContext","vertex","fragment","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","useProgram","position","Float32Array","bufferId","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","vPosition","getAttribLocation","randomTriangles","u_color","Math","random","u_rotation","PI","u_scale","rad","u_time","u_duration","u_dir","cos","sin","startTime","performance","now","setUniforms","loc","getUniformLocation","uniform4fv","uniform1f","uniform2fv","vertexAttribPointer","FLOAT","enableVertexAttribArray","triangles","update","t","i","push","clear","COLOR_BUFFER_BIT","forEach","triangle","drawArrays","TRIANGLES","length","filter","requestAnimationFrame"],"mappings":";AAAA,IAAMA,EAASC,SAASC,cAAc,UAChCC,EAAKH,EAAOI,WAAW,SAEvBC,EAAN,23BAmCMC,EAAN,mMAYMC,EAAeJ,EAAGK,aAAaL,EAAGM,eACxCN,EAAGO,aAAaH,EAAcF,GAC9BF,EAAGQ,cAAcJ,GAEjB,IAAMK,EAAiBT,EAAGK,aAAaL,EAAGU,iBAC1CV,EAAGO,aAAaE,EAAgBN,GAChCH,EAAGQ,cAAcC,GAEjB,IAAME,EAAUX,EAAGY,gBACnBZ,EAAGa,aAAaF,EAASP,GACzBJ,EAAGa,aAAaF,EAASF,GACzBT,EAAGc,YAAYH,GACfX,EAAGe,WAAWJ,GAEd,IAAMK,EAAW,IAAIC,aAAa,EAC/B,GAAI,EACL,EAAG,EACH,GAAI,IAEAC,EAAWlB,EAAGmB,eACpBnB,EAAGoB,WAAWpB,EAAGqB,aAAcH,GAC/BlB,EAAGsB,WAAWtB,EAAGqB,aAAcL,EAAUhB,EAAGuB,aAE5C,IAAMC,EAAYxB,EAAGyB,kBAAkBd,EAAS,YAIhD,SAASe,IACDC,IAAAA,EAAU,CAACC,KAAKC,SAAUD,KAAKC,SAAUD,KAAKC,SAAU,GACxDC,EAAaF,KAAKC,SAAWD,KAAKG,GAClCC,EAA0B,IAAhBJ,KAAKC,SAAkB,IAIjCI,EAAML,KAAKC,SAAWD,KAAKG,GAAK,EAI/B,MAAA,CAACJ,QAAAA,EAASG,WAAAA,EAAYE,QAAAA,EAASE,OAPvB,EAO+BC,WAN3B,EAMuCC,MAH5C,CAACR,KAAKS,IAAIJ,GAAML,KAAKU,IAAIL,IAG0BM,UAF/CC,YAAYC,OAKhC,SAASC,EAAY1C,EAA+D,GAA1D2B,IAAAA,EAAAA,EAAAA,QAASG,EAAAA,EAAAA,WAAYE,EAAAA,EAAAA,QAASE,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,MACtEO,EAAM3C,EAAG4C,mBAAmBjC,EAAS,WACzCX,EAAG6C,WAAWF,EAAKhB,GAEnBgB,EAAM3C,EAAG4C,mBAAmBjC,EAAS,cACrCX,EAAG8C,UAAUH,EAAKb,GAElBa,EAAM3C,EAAG4C,mBAAmBjC,EAAS,WACrCX,EAAG8C,UAAUH,EAAKX,GAElBW,EAAM3C,EAAG4C,mBAAmBjC,EAAS,UACrCX,EAAG8C,UAAUH,EAAKT,GAElBS,EAAM3C,EAAG4C,mBAAmBjC,EAAS,cACrCX,EAAG8C,UAAUH,EAAKR,GAElBQ,EAAM3C,EAAG4C,mBAAmBjC,EAAS,SACrCX,EAAG+C,WAAWJ,EAAKP,GAlCrBpC,EAAGgD,oBAAoBxB,EAAW,EAAGxB,EAAGiD,OAAO,EAAO,EAAG,GACzDjD,EAAGkD,wBAAwB1B,GAoC3B,IAAI2B,EAAY,GAChB,SAASC,EAAOC,GACV,IAAA,IAAIC,EAAI,EAAGA,EAAI,EAAI1B,KAAKC,SAAUyB,IACpCH,EAAUI,KAAK7B,KAEjB1B,EAAGwD,MAAMxD,EAAGyD,kBACZN,EAAUO,QAAQ,SAACC,GACjBA,EAASzB,QAAUM,YAAYC,MAAQkB,EAASpB,WAAa,IAC7DG,EAAY1C,EAAI2D,GAChB3D,EAAG4D,WAAW5D,EAAG6D,UAAW,EAAG7C,EAAS8C,OAAS,KAGnDX,EAAYA,EAAUY,OAAO,SAACJ,GACrBA,OAAAA,EAASzB,QAAUyB,EAASxB,aAErC6B,sBAAsBZ,GAGxBY,sBAAsBZ","file":"04_particles_animation.7297bca7.js","sourceRoot":"..","sourcesContent":["const canvas = document.querySelector('canvas');\nconst gl = canvas.getContext('webgl');\n\nconst vertex = `\n  attribute vec2 position;\n  uniform float u_rotation;\n  uniform float u_time;\n  uniform float u_duration;\n  uniform float u_scale;\n  uniform vec2 u_dir;\n  varying float vP;\n  void main() {\n    float p = min(1.0, u_time / u_duration);\n    float rad = u_rotation + 3.14 * 10.0 * p;\n    float scale = u_scale * p * (2.0 - p);\n    vec2 offset = 2.0 * u_dir * p * p;\n    mat3 translateMatrix = mat3(\n      1.0, 0.0, 0.0,\n      0.0, 1.0, 0.0,\n      offset.x, offset.y, 1.0\n    );\n    mat3 rotateMatrix = mat3(\n      cos(rad), sin(rad), 0.0,\n      -sin(rad), cos(rad), 0.0,\n      0.0, 0.0, 1.0\n    );\n    mat3 scaleMatrix = mat3(\n      scale, 0.0, 0.0,\n      0.0, scale, 0.0,\n      0.0, 0.0, 1.0\n    );\n    gl_PointSize = 1.0;\n    vec3 pos = translateMatrix * rotateMatrix * scaleMatrix * vec3(position, 1.0);\n    gl_Position = vec4(pos, 1.0);\n    vP = p;\n  }\n`;\n\nconst fragment = `\n  precision mediump float;\n  \n  uniform vec4 u_color;\n  varying float vP;\n  void main()\n  {\n    gl_FragColor.xyz = u_color.xyz;\n    gl_FragColor.a = (1.0 - vP) * u_color.a;\n  }    \n`;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER);\ngl.shaderSource(vertexShader, vertex);\ngl.compileShader(vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\ngl.shaderSource(fragmentShader, fragment);\ngl.compileShader(fragmentShader);\n\nconst program = gl.createProgram();\ngl.attachShader(program, vertexShader);\ngl.attachShader(program, fragmentShader);\ngl.linkProgram(program);\ngl.useProgram(program);\n\nconst position = new Float32Array([\n  -1, -1,\n  0, 1,\n  1, -1,\n]);\nconst bufferId = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, bufferId);\ngl.bufferData(gl.ARRAY_BUFFER, position, gl.STATIC_DRAW);\n\nconst vPosition = gl.getAttribLocation(program, 'position');\ngl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(vPosition);\n\nfunction randomTriangles() {\n  const u_color = [Math.random(), Math.random(), Math.random(), 1.0]; // 随机颜色\n  const u_rotation = Math.random() * Math.PI; // 初始旋转角度\n  const u_scale = Math.random() * 0.05 + 0.03; // 初始大小\n  const u_time = 0;\n  const u_duration = 3.0; // 持续3秒钟\n\n  const rad = Math.random() * Math.PI * 2;\n  const u_dir = [Math.cos(rad), Math.sin(rad)]; // 运动方向\n  const startTime = performance.now();\n\n  return {u_color, u_rotation, u_scale, u_time, u_duration, u_dir, startTime};\n}\n\nfunction setUniforms(gl, {u_color, u_rotation, u_scale, u_time, u_duration, u_dir}) {\n  let loc = gl.getUniformLocation(program, 'u_color');\n  gl.uniform4fv(loc, u_color);\n\n  loc = gl.getUniformLocation(program, 'u_rotation');\n  gl.uniform1f(loc, u_rotation);\n\n  loc = gl.getUniformLocation(program, 'u_scale');\n  gl.uniform1f(loc, u_scale);\n\n  loc = gl.getUniformLocation(program, 'u_time');\n  gl.uniform1f(loc, u_time);\n\n  loc = gl.getUniformLocation(program, 'u_duration');\n  gl.uniform1f(loc, u_duration);\n\n  loc = gl.getUniformLocation(program, 'u_dir');\n  gl.uniform2fv(loc, u_dir);\n}\n\nlet triangles = [];\nfunction update(t) {\n  for(let i = 0; i < 5 * Math.random(); i++) {\n    triangles.push(randomTriangles());\n  }\n  gl.clear(gl.COLOR_BUFFER_BIT);\n  triangles.forEach((triangle) => {\n    triangle.u_time = (performance.now() - triangle.startTime) / 1000;\n    setUniforms(gl, triangle);\n    gl.drawArrays(gl.TRIANGLES, 0, position.length / 2);\n  });\n\n  triangles = triangles.filter((triangle) => {\n    return triangle.u_time <= triangle.u_duration;\n  });\n  requestAnimationFrame(update);\n}\n\nrequestAnimationFrame(update);"]}